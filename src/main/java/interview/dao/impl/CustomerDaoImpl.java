package interview.dao.impl;

import interview.dao.CustomerDao;
import interview.dao.mapper.CustomerMapper;
import interview.entity.Customer;
import interview.exception.DbOperationException;
import interview.exception.NotFoundException;
import interview.exception.RecordExistException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Repository;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Optional;

@Repository
public class CustomerDaoImpl implements CustomerDao {

    private JdbcTemplate jdbcTemplate;
    private Logger logger = LoggerFactory.getLogger(CustomerDaoImpl.class);
    private CustomerMapper mapper;
    private final BCryptPasswordEncoder encoder;

    @Autowired
    public CustomerDaoImpl(DataSource dataSource, CustomerMapper mapper, BCryptPasswordEncoder encoder) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.mapper = mapper;
        this.encoder = encoder;
    }

    @Override
    public Customer findByEmail(String email) {
        try {
            return jdbcTemplate.queryForObject(Queries.SQL_GET_CUSTOMER_BY_EMAIL, mapper, email);
        } catch (EmptyResultDataAccessException ex) {
            logger.error("Customer by email: {} not found. Message: {}", email, ex.getLocalizedMessage());
            throw new NotFoundException("Customer by email: "+email+" not found");
        } catch (Exception e) {
            logger.error("Customer find by email: {} exception. Message: {}", email, e.getLocalizedMessage());
            throw new DbOperationException("Customer find by email: "+email+" exception");
        }
    }

    @Override
    public Customer create(Customer customer) {
        try {
            KeyHolder holder = new GeneratedKeyHolder();
            String encodedPassword = encoder.encode(customer.getPassword());
            customer.setPassword(encodedPassword);
            jdbcTemplate.update(con -> createStatement(customer, con), holder);
            customer.setId(Optional.ofNullable(holder.getKey()).map(Number::longValue)
            .orElseThrow(() -> new DbOperationException("Create customer error: Autogenerated key is null")));
        } catch (DataIntegrityViolationException ex) {
            logger.error("Violation of database constraints. Message: {}", ex.getLocalizedMessage());
            throw new RecordExistException("Please, provide unique email");
        } catch (Exception e) {
            logger.error("Create customer {} exception. Message: {}", customer, e.getLocalizedMessage());
        } return customer;
    }

    private PreparedStatement createStatement(Customer customer, Connection con) throws SQLException {
        PreparedStatement ps = con.prepareStatement(Queries.SQL_CREATE_CUSTOMER, Statement.RETURN_GENERATED_KEYS);
        ps.setString(1, customer.getEmail());
        ps.setString(2, customer.getPassword());
        ps.setString(3, customer.getFirstName());
        ps.setString(4, customer.getLastName());
        ps.setBoolean(5, customer.isCertified());
        return ps;
    }

    private class Queries {
        static final String SQL_GET_CUSTOMER_BY_EMAIL = "SELECT * FROM customers WHERE email = ?";
        static final String SQL_CREATE_CUSTOMER = "INSERT INTO customers(email, password, first_name, " +
                "last_name, certified) VALUES(?,?,?,?,?)";
    }
}
